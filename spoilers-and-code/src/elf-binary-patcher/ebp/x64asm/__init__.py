# project imports
from inspect import Traceback
from typing import Callable, Iterator, TypeVar, Type
from .base import x64Instruction, CompilationState

# instructions
from .inc_rbx import INC_RBX
from .dec_rbx import DEC_RBX
from .add_rbx_imm8 import ADD_RBX_imm8
from .sub_rbx_imm8 import SUB_RBX_imm8
from .mov_qwordptr_rbx_rax import MOV_QWORDPTR_RBX_RAX
from .mov_dwordptr_rbx_eax import MOV_DWORDPTR_RBX_EAX
from .mov_byteptr_rbx_imm8 import MOV_BYTEPTR_RBX_imm8
from .mov_rax_qwordptr_ripoff import MOV_RAX_QWORDPTR_ripoff
from .mov_eax_dwordptr_ripoff import MOV_EAX_DWORDPTR_ripoff
from .mov_cl_imm8 import MOV_CL_imm8
from .shl_rdx_cl import SHL_RDX_CL
from .xor_dl_byteptr_ripoff import XOR_DL_BYTEPTR_ripoff
from .xor_dl_imm8 import XOR_DL_imm8
from .xor_rax_rdx import XOR_RAX_RDX
from .jmp_ripoff import JMP_ripoff
from .junk_byte import JunkByte
from .mov_dwordptr_rbx_imm8off_imm32 import MOV_DWORDPTR_RBX_imm8off_imm32
from .lea_rbx_ripoff import LEA_RBX_ripoff


## The Self type for @ref ScopedJunkHook objects
ScopedJunkHookType = TypeVar('ScopedJunkHookType', bound='ScopedJunkHook')


## Hooks notifications for junk bytes within the given context.
class ScopedJunkHook(object):

    ## Creates a new instance of this object.
    #  @param self the instance of the object that is invoking this method.
    #  @param func the function to recieve notifications whilst in the scope.
    def __init__(self, func:Callable[[int], None]) -> ScopedJunkHookType:
        self.old_notify = None
        self.notify = func

    ## Enters the context.
    #  @param self the instance of the object that is invoking this method.
    def __enter__(self) -> ScopedJunkHookType:
        self.old_notify = JunkByte.JunkByteHook
        JunkByte.JunkByteHook = self.notify
        return self

    ## Leaves the context
    #  @param self the instance of the object that is invoking this method.
    def __exit__(self, exc_type:Type, exc_value:Exception, traceback:Traceback) -> None:
        JunkByte.JunkByteHook = self.old_notify


## A list of instructions.
#  Wrapper for basic list type that we can hang some convience methods off.
class InstructionList(list[x64Instruction]):



    ## Gets an iterator expressing the instructions in this list as machine opcodes.
    #  @param virtual_memory_address the VMA that the instructions will be injected into.
    #  @returns interator[int] of opcodes in this list.
    def opcodes_iter(self, virtual_memory_address:int) -> Iterator[int]:
        state = CompilationState(virtual_memory_address)
        for instruction in self:
            compiled_opcodes = instruction(state)
            assert len(compiled_opcodes) == instruction.opcodes_length(), \
                f"Unexpected number of opcodes generated for '{instruction}'; expected {instruction.opcodes_length()} but got {len(compiled_opcodes)} - {compiled_opcodes.hex()}"
            state.virtual_memory_address += len(compiled_opcodes)
            yield from compiled_opcodes
        return
        yield


    ## Gets this list of instructions as a binary blog of machine opcodes.
    #  @param virtual_memory_address the VMA that the instructions will be injected into.
    #  @returns bytearray containing x64 intel opcodes.
    def opcodes(self, virtual_memory_address:int) -> bytearray:
        return bytearray(self.opcodes_iter(virtual_memory_address))


    ## Gets the length of the opcode generated by these instructions.
    #  @returns The number of bytes these assembly instructions occupy as machine opcodes.
    def opcodes_length(self) -> int:
        return sum( asm.opcodes_length() for asm in self )


    ## Computes the informal name of this object.
    #  Displays the instructions as INTEL flavor assembly.
    #  @returns a Friendly string that represents the data contained in this object.
    def __str__(self) -> str:
        instruction_strings = map(str, self)
        return "\n".join(instruction_strings)
