# CV Builder

The top-level build tool for the CV CTF document.

The source for this project is in the [`./spoilers-and-code/src/cv-builder`](./) directory.

## Dependencies

| Dependency Name | Description |
| -- | -- | 
| [`gcc`](https://gcc.gnu.org/) | Build tool used to compile C code.|
| [`pyminizip`](https://pypi.org/project/pyminizip/) | Used to create encrypted ZIP files. |
| (internal) [`elf-binary`](../elf-binary/README.md) | The 64-bit ELF binary (the core of the crackme; used as package contents - not directly needed). |
| (internal) [`elf-binary-launcher`](../elf-binary-launcher/README.md) | The 32-bit ELF wrapped/launcher (the wrapping layer of the crack me; used as package contents - not directly needed). |
| (internal) [`elf-binary-patcher`](../elf-binary-patcher/README.md) / `ebp` | Used to modify and finalise ELF crackme binaries. |
| (internal) [`pdf-patcher`](../pdf-patcher/README.md) / `pdfp` | Used to modify and finalise PDF documents. |

## Setup

Consider creating a dedicated Python virtual environment for this tool.

```shell
# create a virtual environment
python -m venv venv

# update the pip package manager
venv/bin/python -m pip install --upgrade pip

# install this project (editable)
venv/bin/python -m pip install -e .
```

## Usage

Registers as top-level `cv` python module; accessable from command line with usage as:

```shell
venv/bin/python -m cv [-l {debug|info|warn|error}] { command... }
```

For 99.9% of the time after development the process will be:

```shell
# 1. make changes to the base layer 'assets/cv.pdf'.

#2. rebuild the cv
venv/bin/python -m cv build

#3. check/test anything and everything.

#4. commit changes to the repository (the build process will have updated the version-history.md file)
git add ./release-history.md
git commit -m "Made changes to CV content; updated 'release-history.md' to reflect this."

#5. apply changes to the public-repository.
find ~/src/DANGER-cv-public/ -not \( -path "*/.git" -prune \) -delete
venv/bin/python -m cv export-public ~/src/DANGER-cv-public/

#6. check the output of the export-public command for information leaks.

#7. check the status of the repository for unexpected changes.
cd ~/src/DANGER-cv-public/
git status

# 8. push all the changes to the public repository.
git add .
git commit -m "Mirroring changes to public CV-CTF repository (https://github.com/wintersdeep/cv-ctf)."
git push origin master
```

The following commands are available (use `python -m cv {command} --help` for information about arguments)

| Command | Description |
| ---- | ---- |
| `build-crackme-internal` | Builds the 64-bit components of the ELF crackme binary. Note that this is just a compilation of the C source in [`elf-binary`](../elf-binary/) directory. It handles setting of flags and passwords, but it is otherwise just a predefined call to `gcc`. It is important to be aware that the output of this process is NOT a runnable executable. Dynamically generated components of the binary (such as protected strings and the memory integrity process) are not created at this stage - these are required for this binary to work and can be injected with `patch-crackme-internal`; see that for more.|
| `patch-crackme-internal` | "Patches" the missing components of the 64-bit ELF crackme binary; injects instructions to build protected and sensitive strings, calculates memory integrity hashes, and all that stuff. The result of this process is standalone 64-bit binary that can be debugged in isolation. This process can only be run on an unpatched binary (it will fail if the binary is already patched). Every time this process is ran it will create a different output binary - the instructions and seed values generated by this process are random.|
| `build-crackme-launcher` | Builds the 32-bit components of the ELF crackme binary. This includes generating a new `payload.h` file that embeds the 64-bit internal executable code but does not include building the 64-bit binary itself. This must be done proir to running this command as you'll need to provide a path to the binary to embed. Note that this command is intended for debugging only - it does not strip the binary. Stripping is only performed for the `build` and `build-crackme` commands.|
| `build-crackme` | This command builds the crackme binary from the ground up. This is basically a chained version of `build-crackme-internal` &raquo; `patch-crackme-internal` &raquo; `build-crackme-launcher`. It will also strip the resulting binary. This binary is in a "ready-to-ship" state; its useful when making changes to the CTF to ensure you've not added anything "unexpected" without having to build all the other CV components.|
| `build-final-message-zip` | This commands creates the _"final-message"_ ZIP file. This ZIP file is currently the last flag in the CTF; the ZIP is encrypted and contains a single text file which gives a final flag and parting message. The password for this ZIP is released by the crackme binary.|
| `build-flag3-zip` | This command builds create the third-flag ZIP file. This ZIP file is currently embedded in an PDF images data stream; the ZIP  is encrypted and contains a README, the _"final-message"_ ZIP, and the ELF crackme binary. The password for this ZIP is expected to be flag #1 and #2 joined by a space. This command requires that the _"final-message"_ ZIP and crackme binaries are already built; this can be done with the `build-crackme` and `build-final-message-zip` commands.|
| `build-pdf-hidden-layer` | This command builds the "hidden layer" or previous version PDF used for the second flag - note this is a stand alone document, not the final "layered" one (see `build-layered-pdf`). This creates the second flag QR code, and embeds the third flag/image into the document. The third flag ZIP must already exist for this command to function, see `build-flag3-zip`. |
| `build-layered-pdf` | This is basically a thin shim for `pdfp version-layered-pdf`; see [`pdf-patcher`](../pdf-patcher/) documentation for more information. It is used for testing PDF layering and was made because I was being lazy.|
| `build` | The top-most build command that will take the source and compile it into a "ready-to-ship" CV PDF. This command doesn't require any other commands to be run before, and always builds from the ground up (it shouldn't reuse previous builds to ensure that random aspects are uniquely generated). It does require a configuration file. If a specific one is not given one the command line then a default path exists; however this default file is not checked into this source control repository as it contains secrets. See below for an example of how this file looks. |
| `export-public` | This command exports the current state of the `master` branch to another directory, similar to the `svn export` command. This command is used to copy the private repository into one that can be used for the public github copy. It has several benefits - it does some heuristic scanning of the repository for accidental data leaks (don't want to accidently push my CV to github), it removes all the commit history (the private repository has included PII in intermediate commits/references and this makes sure that doesn't accidently leak), it also makes sure that the right content is pushed (that the repository has no uncommited changes, and is the correct branch). |

## Sample Configuration File

The following is an example of what a configuration file for the `build` command looks like.

> NOTE: `$.flags[0]` is currently ignored and needs to be manually set in the base CV layer. 

```json
{
    "flags": [
        "ABCD FLAG1",
        "BCDE FLAG2",
        "CDEF FLAG3",
        "DEFG FLAG4"
    ],
    "cv-path": "./cv.pdf",
    "flag3-message": "./flag3-message.txt",
    "final-message": "./final-message.txt",
    "elf-password": "crackme-password",
    "hidden-layer": {
        "base": "./hidden-layer-base.pdf",
        "qr-rectangle": [ 0, 1, 2, 3 ],
        "qr-message": "./flag2-message.txt",
        "qr-stroke": "rgba(0, 0, 0, 1.0)",
        "qr-fill": "rgba(0, 0, 0, 1.0)",
        "qr-page": 0,
        "image-rectangle": [ 0, 1, 2, 3 ],
        "image-path": "./hidden-layer-image.png",
        "image-page": 0
    },
    "build-paths":
    {
        "elf64":            "../build/crackme64",
        "elf32":            "../build/crackme32",
        "final-message":    "../build/final-message.zip",
        "flag3-zip":        "../build/flag3.zip",
        "hidden-layer-pdf": "../build/hidden-layer.pdf",
        "final-cv":         "../build/final-cv.pdf"
    }
}
```